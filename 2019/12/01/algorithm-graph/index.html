<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="DFS and BFSDFS with recursive, while BFS with queue, caution for loops. DFS pseudocode steps:I. if node is Null returnII. access nodeIII. access left node, recursiveIV. access right node, recursive BF">
<meta name="keywords" content="algorithm,graph,shortest path">
<meta property="og:type" content="article">
<meta property="og:title" content="Algorithm: Graph">
<meta property="og:url" content="xvirt.ink/2019/12/01/algorithm-graph/index.html">
<meta property="og:site_name" content="xvirt">
<meta property="og:description" content="DFS and BFSDFS with recursive, while BFS with queue, caution for loops. DFS pseudocode steps:I. if node is Null returnII. access nodeIII. access left node, recursiveIV. access right node, recursive BF">
<meta property="og:locale" content="en">
<meta property="og:image" content="xvirt.ink/2019/12/01/algorithm-graph/DFS.png">
<meta property="og:image" content="xvirt.ink/2019/12/01/algorithm-graph/BFS.png">
<meta property="og:image" content="xvirt.ink/2019/12/01/algorithm-graph/Floyd%20Warshall%20Algorithm.jpg">
<meta property="og:updated_time" content="2019-12-01T08:34:34.058Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Algorithm: Graph">
<meta name="twitter:description" content="DFS and BFSDFS with recursive, while BFS with queue, caution for loops. DFS pseudocode steps:I. if node is Null returnII. access nodeIII. access left node, recursiveIV. access right node, recursive BF">
<meta name="twitter:image" content="xvirt.ink/2019/12/01/algorithm-graph/DFS.png">
    
    
        
          
              <link rel="shortcut icon" href="/images/cherry_256.png">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/cherry_android_192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/cherry_apple.png">
          
        
    
    <!-- title -->
    <title>Algorithm: Graph</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- rss -->
    
    
</head>

<body>
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">Posts</a></li>
         
          <li><a href="/Search/">Search</a></li>
         
          <li><a href="/about">About</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2020/01/05/segment-tree/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2019/10/05/virtualization-aarch64-vs-x86_64/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=xvirt.ink/2019/12/01/algorithm-graph/"><i class="fa fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=xvirt.ink/2019/12/01/algorithm-graph/&text=Algorithm: Graph"><i class="fa fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=xvirt.ink/2019/12/01/algorithm-graph/&title=Algorithm: Graph"><i class="fa fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=xvirt.ink/2019/12/01/algorithm-graph/&is_video=false&description=Algorithm: Graph"><i class="fa fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Algorithm: Graph&body=Check out this article: xvirt.ink/2019/12/01/algorithm-graph/"><i class="fa fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=xvirt.ink/2019/12/01/algorithm-graph/&title=Algorithm: Graph"><i class="fa fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=xvirt.ink/2019/12/01/algorithm-graph/&title=Algorithm: Graph"><i class="fa fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=xvirt.ink/2019/12/01/algorithm-graph/&title=Algorithm: Graph"><i class="fa fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=xvirt.ink/2019/12/01/algorithm-graph/&title=Algorithm: Graph"><i class="fa fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=xvirt.ink/2019/12/01/algorithm-graph/&name=Algorithm: Graph&description="><i class="fa fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#DFS-and-BFS"><span class="toc-number">1.</span> <span class="toc-text">DFS and BFS</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Shortest-Path-Algorithm"><span class="toc-number">2.</span> <span class="toc-text">Shortest Path Algorithm</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Detect-Cycle"><span class="toc-number">3.</span> <span class="toc-text">Detect Cycle</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#References"><span class="toc-number">4.</span> <span class="toc-text">References</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index width mx-auto px2 my4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Algorithm: Graph
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">xvirt</span>
      </span>
      
    <div class="postdate">
        <time datetime="2019-12-01T06:51:13.000Z" itemprop="datePublished">2019-12-01</time>
    </div>


      
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/algorithm/">algorithm</a>, <a class="tag-link" href="/tags/graph/">graph</a>, <a class="tag-link" href="/tags/shortest-path/">shortest path</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h1 id="DFS-and-BFS"><a href="#DFS-and-BFS" class="headerlink" title="DFS and BFS"></a>DFS and BFS</h1><p>DFS with recursive, while BFS with queue, caution for loops.</p>
<p>DFS pseudocode steps:<br>I. if node is Null return<br>II. access node<br>III. access left node, recursive<br>IV. access right node, recursive<br><img src="DFS.png" alt="DFS"></p>
<p>BFS pseudocode steps:<br>I. create queue<br>II. if node is not Null<br>III. push left/right node in queue<br>IV. pop queue, goto step II<br><img src="BFS.png" alt="BFS"></p>
<h1 id="Shortest-Path-Algorithm"><a href="#Shortest-Path-Algorithm" class="headerlink" title="Shortest Path Algorithm"></a>Shortest Path Algorithm</h1><ul>
<li><p><a href="https://www.geeksforgeeks.org/floyd-warshall-algorithm-dp-16/" target="_blank" rel="noopener">Floyd Warshall Algorithm</a><br><strong>All Pairs Shortest Path problem</strong><br>We initialize the solution matrix same as the input graph matrix as a first step. Then we update the solution matrix by considering all vertices as an intermediate vertex. The idea is to one by one pick all vertices and updates all shortest paths which include the picked vertex as an intermediate vertex in the shortest path. When we pick vertex number k as an intermediate vertex, we already have considered vertices {0, 1, 2, .. k-1} as intermediate vertices. For every pair (i, j) of the source and destination vertices respectively, there are two possible cases.<br>1) k is not an intermediate vertex in shortest path from i to j. We keep the value of dist[i][j] as it is.<br>2) k is an intermediate vertex in shortest path from i to j. We update the value of dist[i][j] as dist[i][k] + dist[k][j] if dist[i][j] &gt; dist[i][k] + dist[k][j]<br>The following figure shows the above optimal substructure property in the all-pairs shortest path problem.<br><img src="Floyd Warshall Algorithm.jpg" alt="Floyd Warshall Algorithm"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// Solves the all-pairs shortest path problem using Floyd Warshall algorithm </span><br><span class="line">void floydWarshall (int graph[][V]) </span><br><span class="line">&#123; </span><br><span class="line">    /* dist[][] will be the output matrix that will finally have the shortest  </span><br><span class="line">      distances between every pair of vertices */</span><br><span class="line">    int dist[V][V], i, j, k; </span><br><span class="line">  </span><br><span class="line">    /* Initialize the solution matrix same as input graph matrix. Or  </span><br><span class="line">       we can say the initial values of shortest distances are based </span><br><span class="line">       on shortest paths considering no intermediate vertex. */</span><br><span class="line">    for (i = 0; i &lt; V; i++) </span><br><span class="line">        for (j = 0; j &lt; V; j++) </span><br><span class="line">            dist[i][j] = graph[i][j]; </span><br><span class="line">  </span><br><span class="line">    /* Add all vertices one by one to the set of intermediate vertices. </span><br><span class="line">      ---&gt; Before start of an iteration, we have shortest distances between all </span><br><span class="line">      pairs of vertices such that the shortest distances consider only the </span><br><span class="line">      vertices in set &#123;0, 1, 2, .. k-1&#125; as intermediate vertices. </span><br><span class="line">      ----&gt; After the end of an iteration, vertex no. k is added to the set of </span><br><span class="line">      intermediate vertices and the set becomes &#123;0, 1, 2, .. k&#125; */</span><br><span class="line">    for (k = 0; k &lt; V; k++) </span><br><span class="line">    &#123; </span><br><span class="line">        // Pick all vertices as source one by one </span><br><span class="line">        for (i = 0; i &lt; V; i++) </span><br><span class="line">        &#123; </span><br><span class="line">            // Pick all vertices as destination for the </span><br><span class="line">            // above picked source </span><br><span class="line">            for (j = 0; j &lt; V; j++) </span><br><span class="line">            &#123; </span><br><span class="line">                // If vertex k is on the shortest path from </span><br><span class="line">                // i to j, then update the value of dist[i][j] </span><br><span class="line">                if (dist[i][k] + dist[k][j] &lt; dist[i][j]) &#123;</span><br><span class="line">                    // here we can add an array to record the path</span><br><span class="line">                    // path[j] = k;</span><br><span class="line">                    dist[i][j] = dist[i][k] + dist[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">  </span><br><span class="line">    // Print the shortest distance matrix </span><br><span class="line">    printSolution(dist); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://www.geeksforgeeks.org/bellman-ford-algorithm-dp-23/" target="_blank" rel="noopener">Bellman–Ford Algorithm</a><br><strong>Single Source Shortest Path</strong><br>1) This step initializes distances from source to all vertices as infinite and distance to source itself as 0. Create an array dist[] of size |V| with all values as infinite except dist[src] where src is source vertex.<br>2) This step calculates shortest distances. Do following |V|-1 times where |V| is the number of vertices in given graph.<br>…..a) Do following for each edge u-v<br>………………If dist[v] &gt; dist[u] + weight of edge uv, then update dist[v]<br>………………….dist[v] = dist[u] + weight of edge uv<br>3) This step reports if there is a negative weight cycle in graph. Do following for each edge u-v<br>……If dist[v] &gt; dist[u] + weight of edge uv, then “Graph contains negative weight cycle”<br>The idea of step 3 is, step 2 guarantees shortest distances if graph doesn’t contain negative weight cycle. If we iterate through all edges one more time and get a shorter path for any vertex, then there is a negative weight cycle<br>How does this work? Like other Dynamic Programming Problems, the algorithm calculate shortest paths in bottom-up manner. It first calculates the shortest distances which have at-most one edge in the path. Then, it calculates shortest paths with at-most 2 edges, and so on. After the i-th iteration of outer loop, the shortest paths with at most i edges are calculated. There can be maximum |V| – 1 edges in any simple path, that is why the outer loop runs |v| – 1 times. The idea is, assuming that there is no negative weight cycle, if we have calculated shortest paths with at most i edges, then an iteration over all edges guarantees to give shortest path with at-most (i+1) edges (Proof is simple, you can refer <a href="http://courses.csail.mit.edu/6.006/spring11/lectures/lec15.pdf" target="_blank" rel="noopener">this</a> or <a href="https://www.youtube.com/watch?v=Ttezuzs39nk" target="_blank" rel="noopener">MIT Video Lecture</a>)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">// The main function that finds shortest distances from src to </span><br><span class="line">// all other vertices using Bellman-Ford algorithm.  The function </span><br><span class="line">// also detects negative weight cycle </span><br><span class="line">void BellmanFord(struct Graph* graph, int src) </span><br><span class="line">&#123; </span><br><span class="line">    int V = graph-&gt;V; </span><br><span class="line">    int E = graph-&gt;E; </span><br><span class="line">    int dist[V]; </span><br><span class="line">  </span><br><span class="line">    // Step 1: Initialize distances from src to all other vertices </span><br><span class="line">    // as INFINITE </span><br><span class="line">    for (int i = 0; i &lt; V; i++) </span><br><span class="line">        dist[i] = INT_MAX; </span><br><span class="line">    dist[src] = 0; </span><br><span class="line">  </span><br><span class="line">    // Step 2: Relax all edges |V| - 1 times. A simple shortest </span><br><span class="line">    // path from src to any other vertex can have at-most |V| - 1 </span><br><span class="line">    // edges </span><br><span class="line">    for (int i = 1; i &lt;= V - 1; i++) &#123; </span><br><span class="line">        for (int j = 0; j &lt; E; j++) &#123; </span><br><span class="line">            int u = graph-&gt;edge[j].src; </span><br><span class="line">            int v = graph-&gt;edge[j].dest; </span><br><span class="line">            int weight = graph-&gt;edge[j].weight; </span><br><span class="line">            if (dist[u] != INT_MAX &amp;&amp; dist[u] + weight &lt; dist[v]) &#123;</span><br><span class="line">                // here we can add an array to record the path</span><br><span class="line">                // path[v] = u;</span><br><span class="line">                dist[v] = dist[u] + weight;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">  </span><br><span class="line">    // Step 3: check for negative-weight cycles.  The above step </span><br><span class="line">    // guarantees shortest distances if graph doesn&apos;t contain </span><br><span class="line">    // negative weight cycle.  If we get a shorter path, then there </span><br><span class="line">    // is a cycle. </span><br><span class="line">    for (int i = 0; i &lt; E; i++) &#123; </span><br><span class="line">        int u = graph-&gt;edge[i].src; </span><br><span class="line">        int v = graph-&gt;edge[i].dest; </span><br><span class="line">        int weight = graph-&gt;edge[i].weight; </span><br><span class="line">        if (dist[u] != INT_MAX &amp;&amp; dist[u] + weight &lt; dist[v]) &#123; </span><br><span class="line">            printf(&quot;Graph contains negative weight cycle&quot;); </span><br><span class="line">            return; // If negative cycle is detected, simply return </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">  </span><br><span class="line">    printArr(dist, V); </span><br><span class="line">  </span><br><span class="line">    return; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-greedy-algo-7/" target="_blank" rel="noopener">Dijkstra’s shortest path algorithm</a></p>
</li>
</ul>
<h1 id="Detect-Cycle"><a href="#Detect-Cycle" class="headerlink" title="Detect Cycle"></a>Detect Cycle</h1><ul>
<li><p><a href="https://www.geeksforgeeks.org/topological-sorting-indegree-based-solution/" target="_blank" rel="noopener">Kahn’s algorithm</a><br>Steps involved in finding the topological ordering of a DAG(Directed Acyclic Graph):<br><em>Step-1:</em> Compute in-degree (number of incoming edges) for each of the vertex present in the DAG and initialize the count of visited nodes as 0.<br><em>Step-2:</em> Pick all the vertices with in-degree as 0 and add them into a queue (Enqueue operation)<br><em>Step-3:</em> Remove a vertex from the queue (Dequeue operation) and then.</p>
<ul>
<li>Increment count of visited nodes by 1.</li>
<li>Decrease in-degree by 1 for all its neighboring nodes.</li>
<li>If in-degree of a neighboring nodes is reduced to zero, then add it to the queue.</li>
</ul>
<p><em>Step 5:</em> Repeat Step 3 until the queue is empty.<br><em>Step 5:</em> If count of visited nodes is not equal to the number of nodes in the graph then the topological sort is not possible for the given graph. <em>There is a loop when the queue size not equal the vertices.</em></p>
</li>
<li><p>union–find data structure<br>A disjoint-set data structure is a data structure that keeps track of a set of elements partitioned into a number of disjoint (non-overlapping) subsets. A union-find algorithm is an algorithm that performs two useful operations on such a data structure:<br>Find: Determine which subset a particular element is in. This can be used for determining if two elements are in the same subset.<br>Union: Join two subsets into a single subset.</p>
<ul>
<li><p>naive way</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// A utility function to find the subset of an element i </span><br><span class="line">int find(int parent[], int i) </span><br><span class="line">&#123; </span><br><span class="line">    if (parent[i] == -1) </span><br><span class="line">        return i; </span><br><span class="line">    return find(parent, parent[i]); </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line">// A utility function to do union of two subsets  </span><br><span class="line">void Union(int parent[], int x, int y) </span><br><span class="line">&#123; </span><br><span class="line">    int xset = find(parent, x); </span><br><span class="line">    int yset = find(parent, y); </span><br><span class="line">    if(xset!=yset)&#123; </span><br><span class="line">       parent[xset] = yset; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line">// The main function to check whether a given graph contains  </span><br><span class="line">// cycle or not </span><br><span class="line">int isCycle( struct Graph* graph ) </span><br><span class="line">&#123; </span><br><span class="line">    // Allocate memory for creating V subsets </span><br><span class="line">    int *parent = (int*) malloc( graph-&gt;V * sizeof(int) ); </span><br><span class="line">  </span><br><span class="line">    // Initialize all subsets as single element sets </span><br><span class="line">    memset(parent, -1, sizeof(int) * graph-&gt;V); </span><br><span class="line">  </span><br><span class="line">    // Iterate through all edges of graph, find subset of both </span><br><span class="line">    // vertices of every edge, if both subsets are same, then  </span><br><span class="line">    // there is cycle in graph. </span><br><span class="line">    for(int i = 0; i &lt; graph-&gt;E; ++i) </span><br><span class="line">    &#123; </span><br><span class="line">        int x = find(parent, graph-&gt;edge[i].src); </span><br><span class="line">        int y = find(parent, graph-&gt;edge[i].dest); </span><br><span class="line">  </span><br><span class="line">        if (x == y) </span><br><span class="line">            return 1; </span><br><span class="line">  </span><br><span class="line">        Union(parent, x, y); </span><br><span class="line">    &#125; </span><br><span class="line">    return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>optimize with rank and path compression</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">struct subset </span><br><span class="line">&#123; </span><br><span class="line">    int parent; </span><br><span class="line">    int rank; </span><br><span class="line">&#125;; </span><br><span class="line">  </span><br><span class="line">// Creates a graph with V vertices and E edges </span><br><span class="line">struct Graph* createGraph(int V, int E) </span><br><span class="line">&#123; </span><br><span class="line">    struct Graph* graph = (struct Graph*) malloc( sizeof(struct Graph) ); </span><br><span class="line">    graph-&gt;V = V; </span><br><span class="line">    graph-&gt;E = E; </span><br><span class="line">  </span><br><span class="line">    graph-&gt;edge = (struct Edge*) malloc( graph-&gt;E * sizeof( struct Edge ) ); </span><br><span class="line">  </span><br><span class="line">    return graph; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line">// A utility function to find set of an element i </span><br><span class="line">// (uses path compression technique) </span><br><span class="line">int find(struct subset subsets[], int i) </span><br><span class="line">&#123; </span><br><span class="line">    // find root and make root as parent of i (path compression) </span><br><span class="line">    if (subsets[i].parent != i) </span><br><span class="line">        subsets[i].parent = find(subsets, subsets[i].parent); </span><br><span class="line">  </span><br><span class="line">    return subsets[i].parent; </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line">// A function that does union of two sets of x and y </span><br><span class="line">// (uses union by rank) </span><br><span class="line">void Union(struct subset subsets[], int x, int y) </span><br><span class="line">&#123; </span><br><span class="line">    int xroot = find(subsets, x); </span><br><span class="line">    int yroot = find(subsets, y); </span><br><span class="line">  </span><br><span class="line">    // Attach smaller rank tree under root of high rank tree </span><br><span class="line">    // (Union by Rank) </span><br><span class="line">    if (subsets[xroot].rank &lt; subsets[yroot].rank) </span><br><span class="line">        subsets[xroot].parent = yroot; </span><br><span class="line">    else if (subsets[xroot].rank &gt; subsets[yroot].rank) </span><br><span class="line">        subsets[yroot].parent = xroot; </span><br><span class="line">  </span><br><span class="line">    // If ranks are same, then make one as root and increment </span><br><span class="line">    // its rank by one </span><br><span class="line">    else</span><br><span class="line">    &#123; </span><br><span class="line">        subsets[yroot].parent = xroot; </span><br><span class="line">        subsets[xroot].rank++; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a href="https://www.geeksforgeeks.org/fundamentals-of-algorithms/" target="_blank" rel="noopener">Geeks Algorithms</a></li>
</ul>

  </div>
</article>



    </div>
    
      <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">Posts</a></li>
         
          <li><a href="/Search/">Search</a></li>
         
          <li><a href="/about">About</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#DFS-and-BFS"><span class="toc-number">1.</span> <span class="toc-text">DFS and BFS</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Shortest-Path-Algorithm"><span class="toc-number">2.</span> <span class="toc-text">Shortest Path Algorithm</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Detect-Cycle"><span class="toc-number">3.</span> <span class="toc-text">Detect Cycle</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#References"><span class="toc-number">4.</span> <span class="toc-text">References</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=xvirt.ink/2019/12/01/algorithm-graph/"><i class="fa fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=xvirt.ink/2019/12/01/algorithm-graph/&text=Algorithm: Graph"><i class="fa fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=xvirt.ink/2019/12/01/algorithm-graph/&title=Algorithm: Graph"><i class="fa fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=xvirt.ink/2019/12/01/algorithm-graph/&is_video=false&description=Algorithm: Graph"><i class="fa fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Algorithm: Graph&body=Check out this article: xvirt.ink/2019/12/01/algorithm-graph/"><i class="fa fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=xvirt.ink/2019/12/01/algorithm-graph/&title=Algorithm: Graph"><i class="fa fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=xvirt.ink/2019/12/01/algorithm-graph/&title=Algorithm: Graph"><i class="fa fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=xvirt.ink/2019/12/01/algorithm-graph/&title=Algorithm: Graph"><i class="fa fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=xvirt.ink/2019/12/01/algorithm-graph/&title=Algorithm: Graph"><i class="fa fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=xvirt.ink/2019/12/01/algorithm-graph/&name=Algorithm: Graph&description="><i class="fa fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
      <ul>
        <li id="toc"><a class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa fa-list fa-lg" aria-hidden="true"></i> TOC</a></li>
        <li id="share"><a class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa fa-share-alt fa-lg" aria-hidden="true"></i> Share</a></li>
        <li id="top" style="display:none"><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a></li>
        <li id="menu"><a class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa fa-bars fa-lg" aria-hidden="true"></i> Menu</a></li>
      </ul>
    </div>

  </div>
</div>

    
    <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2021 Henry
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">Posts</a></li>
         
          <li><a href="/Search/">Search</a></li>
         
          <li><a href="/about">About</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

</body>
</html>
<!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
<link rel="stylesheet" href="/lib/meslo-LG/styles.css">
<link rel="stylesheet" href="/lib/justified-gallery/justifiedGallery.min.css">

<!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>


    <!-- Google Analytics -->
    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-37473492-6', 'auto');
        ga('send', 'pageview');
    </script>



